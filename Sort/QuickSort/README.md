## 퀵 정렬<br>
<br>
시간 복잡도 : 평균 - O(nlogn), 최악 - O(n^2)<br>
<br>
퀵 정렬은 아래의 두 가지 기본 작업을 반복 수행하여 완성한다.<br>
(1) 분할(divide) : 정렬할 자료들을 기준값을 중심으로 2개의 부분집합으로 분할한다.<br>
(2) 정복(conquer) : 부분집합의 원소들 중에서 기준값보다 작은 원소들을 왼쪽 부분집합으로, 기준값보다 큰 원소들을 오른쪽 부분집합으로 정렬한다. 부분집합의 크기가 1 이하로 충분히 작지 않으면 순환 호출을 이용하여 다시 분할한다.<br>
<br>
분할 작업을 순환적으로 반복하며 피봇의 왼쪽 부분집합과 오른쪽 부분집합을 정렬하는 방법을 반복한다.<br>
<br>
1. 초기에 begin은 0, end는 배열크기-1로 설정한다.<br>
2. L=begin, R=end로 설정한다.<br>
3. L은 왼쪽에서 오른쪽으로 가며 피봇 값보다 크거나 같을 경우, 멈춘다.<br>
4. R은 오른쪽에서 왼쪽으로 가며 피봇 값보다 작을 경우, 멈춘다.<br>
5. L의 인덱스가 R의 인덱스보다 작을 경우, L과 R의 값을 교환한다.<br>
6. 값 교환 후, 만약 L이 피봇인 상태라면 피봇을 R로 재설정한다.<br>
7. L의 인덱스가 R의 인덱스보다 작은 경우, 1. ~ 4.를 반복한다.<br>
8. L과 R의 인덱스가 같은 경우, pivot 값과 R의 값을 교환한다.<br>
9. R을 중심으로 R의 좌측 부분집합, 우측 부분집합으로 나누어 앞서 수행한 작업을 반복한다. 즉, begin=begin, end=R-1 그리고 begin=R+1, end=end로 나누어 작업을 반복한다. (begin이 end보다 작을 때까지 2.~9. 를 반복)<br>
<br>
퀵 정렬의 pivot 값은 배열 가장 처음 값 혹은 끝 값등 마음대로 설정할 수 있으나, 가장 좋은 것은 배열 안에 있는 모든 것의 평균 값이다. 평균 값이 pivot이 되면 첫 pass에 평균값보다 큰 배열과 작은 배열이 반반씩 균등히 나뉘어지므로 최고의 효율을 낼 수 있다. 너무 크거나 작은 값이 pivot으로 선정되면 최악의 경우 한쪽 배열에 한 개, 또 한쪽 배열에 나머지 부분이 들어갈 수도 있다. 이때는 자기 호출의 깊이가 n정도가 되며 실행 시간이 n^2에 비례하게 떨어진다. 한 번의 탐색을 통해 평균을 내어 그 평균과 가장 가까운 pivot값으로 설정하게 만들면 효율을 높일 수 있다. 그런데 그런데, 최적의 pivot 을 찾을 때 오히려 최악의 pivot 값이 선정되어 정렬할 때보다 더 많은 비용이 들 수도 있으므로 신중히 결정해야 한다. 퀵정렬은 무작위 배열 정렬에는 빠르지만 구간이 어느정도 좁혀지면 그다지 빠르지 않으므로 적당한 점까지 퀵 정렬 후, 다음은 삽입 정렬로 대체한다. 삽입 정렬은 대충 정렬한 데이터를 다시 정렬할 때 진가를 발휘한다.
또한, 재귀보다 비재귀를 사용하는 것이 더 좋다. 재귀호출판은 데이터가 매우 커질 경우 Stack Overflow가 날 수 있기 때문이다.<br>
